# 並列実行の注意点・考慮事項

> **Author**: Ashigaru3
> **Created**: 2026-01-29
> **Project**: AI Seminar - Multi-Agent System Research

---

## 概要

マルチエージェントシステム（Claude Code + tmux）による並列開発において、システムの信頼性、効率性、経済性を確保するために必須の考慮事項をまとめる。

---

## 1. ポーリング禁止の理由とイベント駆動設計

### 1.1 なぜポーリングが禁止されるのか

**根本的な理由**: API コストの浪費

Claude Code などの LLM ベースのエージェントシステムにおいて、ポーリング（定期的な状態確認ループ）は以下の問題を引き起こす。

| 問題 | 影響 |
|------|------|
| 不要な API 呼び出し | 待機時間中も課金され続ける |
| コンテキスト肥大化 | ポーリング履歴がコンテキストを圧迫 |
| レスポンス遅延 | ポーリング間隔による遅れが発生 |
| システム効率低下 | 無駄なリソース消費 |

**具体例**:
```bash
# ❌ 悪い例: ポーリング
while true; do
  check_task_status()
  sleep 10
done
# → 10秒ごとに API 呼び出しが発生し、コストが爆発

# ✅ 良い例: イベント駆動
wait_for_signal() {
  # シグナル待機中は API 呼び出しなし
  # 通知が来たら一度だけ処理
}
```

### 1.2 イベント駆動設計への移行

**基本原則**: 「起こされたら動く、起こされるまで待つ」

multi-agent-shogun システムでの実装パターン:

```
【イベント通知フロー】
1. 指示者 → YAMLファイルにタスクを書く
2. 指示者 → tmux send-keys で相手を起こす
3. 実行者 → 一度だけファイルを読んで処理
4. 実行者 → 報告書を書く
5. 実行者 → send-keys で指示者を起こす
6. 指示者 → 報告を確認して次のアクション
```

**実装例（tmux send-keys の正しい使い方）**:
```bash
# ❌ 禁止: 一度に送信（Enter を含める）
tmux send-keys -t multiagent:0.1 'check status' Enter

# ✅ 正しい: 2回に分けて送信
# 1回目: メッセージを送信
tmux send-keys -t multiagent:0.1 'ashigaru1、任務完了でござる。報告書を確認されよ。'
# 2回目: Enter を押して実行
tmux send-keys -t multiagent:0.1 Enter
```

**2回に分ける理由**:
- メッセージが確実にペインに反映されるのを待つため
- 一度に送信すると、一部が欠落する可能性がある
- デバッグ時の視認性が向上

### 1.3 イベント駆動のメリット

| メリット | 説明 |
|----------|------|
| **コスト最適化** | 必要な時のみ API 呼び出し |
| **即時応答** | 待機時間なしで即座に処理開始 |
| **可視性向上** | 誰が誰を起こしたか明確 |
| **デバッグ容易** | イベントの流れをトレース可能 |

---

## 2. API コスト最適化のポイント

### 2.1 コスト削減の基本戦略

LLM ベースのマルチエージェントシステムにおいて、API コストは運用コストの大部分を占める。以下の戦略で最適化する。

### 2.2 具体的な最適化手法

#### (1) コンテキスト管理の最適化

```
コンテキストサイズとコストは比例関係
小さく保つ = そのままコスト削減
```

| 手法 | 効果 |
|------|------|
| `/compact` の定期的実行 | 古いメッセージを削除 |
| Task Tool の活用 | サブエージェントにコンテキスト分散 |
| ファイルベース通信 | コンテキストではなくファイルで情報共有 |
| 必要最小限のプロンプト | 冗長な指示を排除 |

#### (2) モデル選択の最適化

| タスクタイプ | 推奨モデル | 理由 |
|--------------|------------|------|
| 軽量タスク・頻繁実行 | Haiku 4.5 | コスト 1/3、90% の性能 |
| メイン開発作業 | Sonnet 4.5 | ベストなコストパフォーマンス |
| 複雑な設計・分析 | Opus 4.5 | 最深の推論が必要な場合のみ |

#### (3) 通信の最適化

```yaml
# ❌ 高コスト: コンテキスト内で全てやり取り
Karo: "足軽1、2、3全員にこの長い指示を読ませて..."
→ 各足軽が同じ長いプロンプトを処理 = コスト3倍

# ✅ 低コスト: ファイルベース通信
Karo:
  - queue/tasks/ashigaru1.yaml に簡潔な指示
  - queue/tasks/ashigaru2.yaml に簡潔な指示
  - queue/tasks/ashigaru3.yaml に簡潔な指示
→ 各足軽は専用ファイルのみ読む = 重複なし
```

### 2.3 コスト監視の指標

以下の指標を継続的に監視する:

| 指標 | 目標値 |
|------|--------|
| 1タスクあたりの平均ターン数 | 10ターン未満 |
| コンテキストサイズ | 100KB 未満（compact 実行基準） |
| 重複読み込みファイル数 | 0 |
| ポーリング回数 | 0 |

---

## 3. 競合状態（レースコンディション）の回避

### 3.1 レースコンディションとは

複数のエージェントが同時に同一リソースにアクセスしようとする状況で、予期せぬ動作やデータ破損が発生する問題。

**multi-agent-shogun システムでのリスク**:
```
足軽1 → output.md に書き込み開始
足軽2 → output.md に書き込み開始（競合！）
→ 最後の書き込みのみ有効に
→ どちらかの作業が失われる
```

### 3.2 システム設計による回避策

#### RACE-001 ルール: 専用ファイル分離

```yaml
# ❌ 禁止: 複数足軽で同一ファイル
足軽1: target_path: "research/output.md"
足軽2: target_path: "research/output.md"  # 競合！

# ✅ 正しい: 各自専用ファイル
足軽1: target_path: "research/output_1.md"
足軽2: target_path: "research/output_2.md"
足軽3: target_path: "research/output_3.md"
```

#### ファイル命名規則の統一

```
research/
├── parallel/
│   ├── 01_overview.md       # 足軽1担当
│   ├── 02_architecture.md   # 足軽2担当
│   └── 03_considerations.md # 足軽3担当
```

ルール:
- プレフィックスで担当を明示
- ファイル名が被らないよう事前に調整
- 必要であれば連番で自動採番

### 3.3 報告書の競合回避

```
queue/reports/
├── ashigaru1_report.yaml  # 足軽1専用
├── ashigaru2_report.yaml  # 足軽2専用
├── ashigaru3_report.yaml  # 足軽3専用
└── ...
```

設計方針:
- 各足軽が自分の報告書のみ書き込み
- 家老が全報告書を読み取り（一方向）
- 書き込み競合の可能性を構造的に排除

### 3.4 競合が発生しうるケースと対策

| ケース | リスク | 対策 |
|--------|--------|------|
| 複数足軽が同じファイルを読む | 低 | 読み取りは安全 |
| 複数足軽が同じファイルに書く | 高 | 禁止（RACE-001） |
| 足軽が書いたファイルを別足軽が読む | 低 | 順序制御で対応 |
| 家老が同時に全報告を読む | 低 | 読み取りは安全 |

**競合リスクがある場合の対応**:
1. タスクの `status` を `blocked` に変更
2. 報告書の `notes` に「競合リスクあり」と記載
3. 家老に調整を依頼

---

## 4. コンテキスト管理の重要性

### 4.1 コンテキストとは

エージェントが作業を行う際に参照できる「記憶」の領域。会話履歴、ファイル内容、設定情報などが含まれる。

**LLM の特性**:
- コンテキストサイズに上限がある
- コンテキストが大きいほど API コストが上がる
- コンテキストの末尾ほど重要視される傾向

### 4.2 コンテキスト管理のベストプラクティス

#### (1) 定期的なコンパクション

```bash
# コンテキストサイズを確認する指標
| 残量 | 対応 |
|------|------|
| 50%以上 | 継続 |
| 20-50% | 注意 |
| 20%以下 | 即座に/compact実行 |
```

`/compact` 実行タイミング:
- Context 残量が 20% 以下
- Web 検索を 5 回以上実行した
- ファイルを 10 個以上読み込んだ
- 大規模なコード生成・分析を行った

#### (2) Task Tool によるコンテキスト分散

**判断基準**:
| 基準 | 閾値 |
|------|------|
| Web 検索回数 | 5 回以上見込み |
| ファイル読み取り | 10 個以上見込み |
| コード分析 | 大規模（500 行以上） |
| ドキュメント作成 | 複数セクション（5 以上） |
| 並列処理が必要 | 独立したサブタスクが 3 つ以上 |

**効果**:
```
メインエージェント: コンテキスト軽量化
サブエージェント: 独立したコンテキストで作業
→ 全体の API コスト削減 + パフォーマンス向上
```

#### (3) ファイルベースの情報共有

```yaml
# ❌ 悪い例: コンテキストで全て渡す
Karo:
  足軽1へ:
    - Aプロジェクトの全ドキュメント（100ファイル分）
    - Bプロジェクトの全ドキュメント（150ファイル分）
    - Cプロジェクトの全ドキュメント（80ファイル分）
  → コンテキスト爆発、コスト高騰

# ✅ 良い例: 必要な情報だけ渡す
Karo:
  queue/tasks/ashigaru1.yaml:
    task_id: subtask_001
    project: project_a
    description: "AプロジェクトのREADME.mdのみ参照せよ"
  → コンテキスト軽量、コスト最適
```

### 4.3 コンテキスト管理のワークフロー

```
【作業開始前】
1. ~/multi-agent-shogun/CLAUDE.md を読む
2. memory/global_context.md を読む
3. config/projects.yaml を読む
4. 自分専用のタスクファイルだけ読む
5. （必要に応じて）context/{project}.md を読む

【作業中】
1. 定期的にコンテキスト残量を確認
2. 20% 以下になったら /compact 実行
3. 大規模作業は Task Tool に委譲

【作業完了後】
1. 報告書に必要な情報だけを残す
2. 次の作業に備えて /compact 実行
```

### 4.4 F005: コンテキスト未読での作業開始を禁止する理由

```
コンテキスト未読で作業開始 → 以下のリスク

1. システム全体の設定を把握できず、不適切な実装
2. 他の足軽の作業状況を把握できず、競合発生
3. 殿の好みや要件を満たせず、やり直し発生
4. 禁止事項に違反し、システム不安定化

→ 結果: 余計な API 呼び出し、コスト増加
```

---

## 5. エラーハンドリング・リカバリー

### 5.1 エラーの分類

マルチエージェントシステムで発生するエラーを分類し、それぞれに適切な対応を定義する。

| エラー種別 | 重大度 | リカバリー方針 |
|------------|--------|----------------|
| タスク実行失敗 | 中 | 報告書に status: failed を記載 |
| 競合状態検出 | 高 | status: blocked で家老に報告 |
| コンテキスト枯渇 | 中 | /compact で復帰 |
| 禁止事項違反 | 高 | 即座に停止、家老に報告 |
| サーバー障害 | 低 | リトライまたは後日再実行 |

### 5.2 報告書によるステータス伝達

```yaml
# 正常完了
status: done
result:
  summary: "任務完了でござる"
  files_modified:
    - "research/parallel/03_considerations.md"

# 失敗
status: failed
result:
  summary: "API接続エラーにより失敗"
  error_details: "Timeout while connecting to external service"
  retry_possible: true

# ブロック（競合または外部要因）
status: blocked
result:
  summary: "ファイル競合により作業中断"
  conflicting_resources:
    - "research/output.md"
  requires_intervention: true
```

### 5.3 コンパクション失敗時のリカバリー

```
【症状】
/compact を実行しても失敗する

【リカバリー手順】
1. Esc を 2 回押す（古いメッセージを強制削除）
2. /compact を再実行
3. それでも失敗したら /clear でリセット（最終手段）

【注意】
/clear は作業中の情報が失われるため、
重要な情報は報告書に書いてから実行せよ
```

### 5.4 エラーからの復旧戦略

#### (1) 原因特定の重要性

```
エラーが発生したら、まず原因を特定せよ：

1. 一時的なエラーか？（再実行で解決）
2. システマティックなエラーか？（設計見直し）
3. 外部要因か？（回避策の検討）

→ 報告書には原因と対策を必ず記載
```

#### (2) 進捗の保存

```
途中経過を必ず保存せよ：

- 完了したサブタスクを記録
- 作業途中のファイルをコミット
- 次にどこから再開すべきかを明記

→ エラー発生後もスムーズに再開可能
```

#### (3) 家老への迅速な報告

```
エラーを検知したら、即座に報告せよ：

1. 報告書を書く
2. send-keys で家老を起こす
3. 次の指示を待つ

→ 決して自己判断でリトライし続けるな
```

### 5.5 耐障害性設計のポイント

| 観点 | 対策 |
|------|------|
| **単一障害点の排除** | どのエージェントが停止してもシステム全体に影響しない設計 |
| **状態の外部化** | コンテキストではなくファイルで状態管理 |
| **冪等性の確保** | 同じ操作を繰り返しても結果が一貫する設計 |
| **フェイルファスト** | 異常を検知したら即座に停止し、被害を最小限に |

---

## 総括

並列実行システムを成功させるための 5 つの柱:

1. **イベント駆動設計**: ポーリングを廃し、効率的な通知システムを実現
2. **API コスト最適化**: コンテキスト管理とモデル選択で経済性を確保
3. **競合状態回避**: 専用ファイル分離でデータ競合を構造的に排除
4. **コンテキスト管理**: 定期的なコンパクションと適切な情報分散
5. **エラーハンドリング**: 明確な報告プロトコルとリカバリー手順

これらを意識した設計こそが、信頼性の高いマルチエージェントシステムへの道となる。

---

## 参考文献

- multi-agent-shogun システム設計書
- instructions/ashigaru.md（禁止事項一覧）
- instructions/karo.md（家老のワークフロー）
- CLAUDE.md（全体構成と通信プロトコル）
